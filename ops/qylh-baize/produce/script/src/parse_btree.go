package main

import (
	"bytes"
	"encoding/xml"
	"io/ioutil"
	"log"
	"os"
	xml2 "parser/xml"
	"path/filepath"
	"strings"
	"text/template"
)

type btree struct {
	ID    string
	Entry string
	Nodes []bnode
}

type event struct {
	Event string
	Node  string
}

type bnode struct {
	ID    string
	Type  string
	Props string
	Nodes string
}

type root struct {
	XMLName xml.Name `xml:"map"`
	Nodes   []node   `xml:"node"`
}

type node struct {
	XMLName xml.Name `xml:"node"`
	Text    string   `xml:"TEXT,attr"`
	ID      string   `xml:"ID,attr"`
	Link    string   `xml:"LINK,attr"`
	Nodes   []node   `xml:"node"`
	Props   []prop   `xml:"attribute"`
}

type prop struct {
	XMLName xml.Name `xml:"attribute"`
	Name    string   `xml:"NAME,attr"`
	Value   string   `xml:"VALUE,attr"`
}

var tplBTreeErl = `%% Automatically generated, do not edit
%% Generated by parse_btree.go

-module({{ .mod }}).

-include("btree.hrl").

-compile([export_all]).
-compile(nowarn_export_all).

{{ range .btrees }}
find({{ .ID }}) -> #btree{
	id    = {{ .ID }},
	entry = '{{ .Entry }}',
	nodes = #{
{{ range $k, $v := .Nodes }}
		{{ if ne $k 0 }}, {{ end }}'{{ .ID }}' => #bnode{
			id    = '{{ $v.ID }}',
			type  = {{ $v.Type }},
			props = {{ $v.Props }},
			nodes = {{ $v.Nodes }}
		}
{{ end }}
	}
};
{{ end }}
find(_) -> undefined.
`

var btrees = make([]btree, 0, 10)
var bnodes []bnode

func main() {
	err := filepath.Walk(os.Args[1], func(path string, f os.FileInfo, err error) error {
		if !f.IsDir() && filepath.Ext(path) == ".mm" {
			x := xml2.ParseXML(path, &root{})
			r := x.Data.(*root)
			bnodes = make([]bnode, 0, 20)
			normalize(r.Nodes[0].Nodes[0])
			btrees = append(btrees, btree{
				ID:    r.Nodes[0].Text,
				Entry: r.Nodes[0].Nodes[0].ID,
				Nodes: bnodes,
			})
		}
		return nil
	})

	if err != nil {
		log.Fatalf("解析行为树失败: %v", err)
	}

	buf := bytes.NewBuffer(make([]byte, 0, 1024))
	t := template.New("tpl")
	t, _ = t.Parse(tplBTreeErl)
	mod := strings.TrimSuffix(filepath.Base(os.Args[2]), ".erl")
	err = t.Execute(buf, map[string]interface{}{"mod": mod, "btrees": btrees})
	if err != nil {
		log.Fatalf("解析行为树失败: %v", err)
	}
	err = ioutil.WriteFile(os.Args[2], buf.Bytes(), 0666)
	if err != nil {
		log.Fatalf("生成行为树失败: %v", err)
	}
}

func normalize(n node) {
	var t string
	switch n.Text {
	case "序列节点":
		t = "node_sequence"
	case "选择节点":
		t = "node_selector"
	case "并行节点":
		t = "node_parallel"
	case "循环节点":
		t = "node_repeater"
	case "计数节点":
		t = "node_counter"
	case "随机节点":
		t = "node_random"
	case "成功节点":
		t = "node_success"
	case "失败节点":
		t = "node_failure"
	case "取反节点":
		t = "node_inverter"
	case "条件节点":
		t = "node_condition"
	case "动作节点":
		t = "node_action"
	case "事件节点":
		t = "node_listen"
	case "取消节点":
		t = "node_delisten"
	case "子树节点":
		t = "node_subtree"
	case "跳转节点":
		t = "node_jumper"
	case "延迟节点":
		t = "node_timer"
	case "休眠节点":
		t = "node_sleep"
	case "逗留节点":
		t = "node_linger"
	case "中断节点":
		t = "node_interrupt"
	}

	var ps = make([]string, 0, 5)
	var ns = make([]string, 0, 5)

	if t == "node_jump" {
		ps = append(ps, "{node,'"+n.Link+"'}")
	} else {
		for _, v := range n.Props {
			if v.Name == "args" {
				ps = append(ps, "{"+v.Name+",["+v.Value+"]}")
			} else if v.Name == "tree" {
				ps = append(ps, "{"+v.Name+",["+v.Value+"]}")
			} else if v.Name == "tick" {
				if strings.ContainsAny(v.Value, ",") {
					ps = append(ps, "{"+v.Name+",["+v.Value+"]}")
				} else {
					ps = append(ps, "{"+v.Name+","+v.Value+"}")
				}
			} else {
				ps = append(ps, "{"+v.Name+","+v.Value+"}")
			}
		}

		for _, n2 := range n.Nodes {
			ns = append(ns, "'"+n2.ID+"'")
		}
	}

	bnodes = append(bnodes, bnode{
		ID:    n.ID,
		Type:  t,
		Props: "[" + strings.Join(ps, ",") + "]",
		Nodes: "[" + strings.Join(ns, ",") + "]",
	})
	for _, subNodes := range n.Nodes {
		normalize(subNodes)
	}
}
